

![Pasted image 20240820133841.png](Pasted_image_20240820133841.png)

위의 그림은 푸리에 변환을 잘 나타내는 그림이다. 임의의 신호는 여러개의 사인파와 코사인파로 이루어져 있고 각 사인파와 코사인파에 맞는 진폭만을 표현하는 것이다.

### 1. 왜 변환을 해야 하는가?

---

![Pasted image 20240820134000.png](Pasted_image_20240820134000.png)

진동 신호가 위 그림처럼 간단하고 명확하게만 나타나준다면, 신호에 대한 정보를 얻기가 그렇게 어려운 일은 아니었을 것이다.

하지만, 실제 진동 신호는 노이즈 등의 이유로 굉장히 복잡한 형태를 띄고 있다. 따라서 우리가 구하고자 하는 특정 신호에 대한 정보를 얻기란 매우 쉽지 않다.

### 2. 푸리에 급수

---

![Pasted image 20240820134315.png](Pasted_image_20240820134315.png)

맨 처음 신호가 여러개의 노이즈와 각종 신호가 섞인 신호이며, 점선 밑에는 원본 신호를 이루고 있는 다양한 신호들이다.

위 신호들은 푸리에 급수에 의한 정의로 간단한 주파수로 나타낼 수 있다.

푸리에 급수를 먼저 알아보자, 푸리에 급수은 공학수학 2에서 나오며 중간고사 범위이다.

![Pasted image 20240820135914.png](Pasted_image_20240820135914.png)

x(t)는 우리가 보는 복잡한 신호이고, T_p는 주기이다. 참고로 a_n과 b_n 모두 각 주기에서의 신호의 계수(진폭)이다.

참고로 삼각 함수로 표현한 수식은 더 단순해진다.

![Pasted image 20240820134737.png](Pasted_image_20240820134737.png)

지수함수가 가장 간단한 신호(삼각 함수)를 나타내며 x(t)는 그 신호들의 합으로 이루어진다는 것을 알 수 있다.

이렇게 푸리에 급수를 이용한 푸리에 변환이 가능하다. 하지만, 푸리에 변환은 언제까지나, 주기를 가지는 함수가 미분이 불가능한 지점을 파훼하기 위해 나타난 방법이다.

즉, "주기"가 없으면 사용이 불가능하다. 근데 우리는 이러한 푸리에 급수의 단점을 극복하는 방법또한 배웠다.

### 3. 푸리에 변환 (Fourier Transform)

---

주기 신호에만 적용 가능한 푸리에 급수를 비주기 신호까지 확장한 방법이다. 아이디어는 단순하다. 푸리에 급수는 주기가 있어야 한다. 하지만 일반적인 함수는 주기가 없다. 그렇다면 주기를 무한대로 늘린 푸리에 급수를 적용하면 어떻게 될까?

![Pasted image 20240820140027.png](Pasted_image_20240820140027.png)

위 수식을 아주 잘 알고 있을 것이다.

그런데 너무 복잡하다 단순화하기 위해, 수식을 조금 바꾸자 f = 1/T_p이므로

![Pasted image 20240820140133.png](Pasted_image_20240820140133.png)

이를 수렴한다고 가정한다면, 아래와 같이 적을 수 있다.

![Pasted image 20240820140151.png](Pasted_image_20240820140151.png)

이 식이 바로 그 유명한 푸리에 변환이다. 이 수식을 이용해서 시간에 대한 신호인 x(t)를 주파수에 대한 신호 X(f)로 바꿀 수 있다.

![Pasted image 20240820140305.png](Pasted_image_20240820140305.png)

근데 위 방법도 제한이 있다.

아까 맨 처음에 비주기적인 일반 함수조차 푸리에 급수로 나타내기 위해 주기를 무한대로 확장한 것이 기억나는가?

이게 문제다. 한순간도 끊기지 않은 데이터가 필요하단 것이다. 이건 언제까지나 아날로그 신호에서나 가능한 방법이지, 우리가 쓰는 컴퓨터와 신호 센서는 샘플링을 진행하는 이산 데이터이다...

물론 샘플링 레이트를 높게 해서 변환하면 되긴 한다. 근데 전에도 말했지만 샘플링 레이트를 높게 하면 용량이 몇 GB를 가뿐히 넘어간다. 슈퍼 컴퓨터가 아니고서야 일반적으로 분석이 안된다... (심지어 슈퍼 컴퓨터도 이걸 처리할 수 있을까??)

때문에 아이러니하게 우리가 얻은 정보에는 푸리에 변환을 적용할 수 없다.

### 4. 이산 푸리에 변환 (DFT, Discrete Fourier Transform)

---

이산적인 데이터조차 올바른 푸리에 변환을 진행하기 위해 탄생한 개념이다. 아이디어는 간단하다. 적분을 이용하는 것이다.

기존 푸리에 변환의 수식을 적분을 이용해 N개의 샘플에 대한 Sum으로 바꾼 형태로 바꾸자는 것이다.

![Pasted image 20240820140759.png](Pasted_image_20240820140759.png)

x(t)를 연속적인 데이터로 본다면, `x[n]`은 이상 신호이다. 연속 주파수인 f 또한 이산 주파수 k/N으로 표현한다. 이 수식을 통해 샘플링된 데이터도 Fourier Transform이 가능하게 된다.

근데 이건 그렇게 좋은 방법이 아니다. 왜냐하면 데이터 숫자가 많아질수록 복잡도가 너무 높아지기 때문이다.

DFT 수식을 구현하려면 시간변수 n과 주파수 변수 k가 데이터 개수인 N의 영향을 받아 시간 복잡도가 O(N^2)가 되어버린다. 딥러닝처럼 데이터를 많이 사용해야 하는 경우 비효율적이라는 것

### 5. 고속 푸리에 변환 (FFT)

---

DFT의 시간 복잡도를 해결하기 위해 나온 알고리즘, FFT의 시간 복잡도는 O(NlogN) 이다. 이 기법은 DFT과 그 역변환을 빠르게 수행하기 위한 알고리즘으로, 기본 아이디어는 DFT와 동일하다.

비트의 연산, 알고리즘등 전적으로 컴퓨터 공학적인 내용이라 기계 공학적 진동을 수행하는 우리 팀에게는 그닥 유용한 정보는 아니므로 생략한다.

물론 이 글을 정리하는 나는 알아야 한다.

### 6. Short-Time Fourier Transform (STFT)

---

![Pasted image 20240820155211.png](Pasted_image_20240820155211.png)

일정한 시간 단위로 블록(Window)를 나누는데, 각각의 Window에 FFT를 적용하는 방법이다. 이를 하는 이유는 각 시간 구간마다 어떤 주파수들이 존재하는지 알 수 있기 때문이다.

중요한 점은 Parameter들이다. 각 라이브러리에 따라서 설정값이 다르긴 하나, 크게 보면 아래 4가지 설정값이 존재한다.

![Pasted image 20240820155001.png](Pasted_image_20240820155001.png)

- **n_fft (fft point)**:
STFT를 수행할 때 사용하는 FFT(고속 푸리에 변환)의 포인트 수이다. 이 값은 주파수 해상도를 결정하는데, 일반적으로 2의 거듭제곱으로 설정된다. `n_fft` 값이 클수록 주파수 해상도가 높아지지만, 시간 해상도는 낮아질 수 있다. 기본적으로 `n_fft` 값은 윈도우 크기(`win_length`)와 동일하게 설정되며, 만약 `n_fft`가 `win_length`보다 크면 입력 신호는 `n_fft` 크기만큼 0으로 패딩된다.
- **hop_length (shift size)**:
STFT 계산에서 각 프레임 간의 이동 크기(또는 시프트)를 지정한다. 이 값이 작을수록 프레임 간의 중첩이 많아지며, 시간 해상도가 높아진다. 일반적으로 `hop_length`는 `win_length`의 절반 정도로 설정되지만, 애플리케이션에 따라 조정될 수 있다.
- **win_length (frame length)**:
각 프레임에서 사용하는 윈도우의 크기를 지정한다. 이 값은 `n_fft` 이하의 값으로 설정되며, 주파수 해상도와 시간 해상도에 영향을 미친다. 보통 `n_fft`와 동일하게 설정되지만, 필요에 따라 다르게 설정할 수 있다.
- **window**:
각 프레임에 적용할 윈도우 함수를 지정합니다. 기본값은 'hann' 윈도우입니다. 윈도우 함수는 신호의 경계를 부드럽게 만들어 FFT 계산 시 생길 수 있는 경계 효과를 줄여줍니다. `librosa`는 'hann', 'hamming', 'blackman' 등 다양한 윈도우 함수를 지원합니다.

저 중간에 n_fft는 뭔지 잘 모를것이기에 추가적으로 설명을 하겠다.

만약 다음과 같은 신호가 있다고 하자

![Pasted image 20240820155957.png](Pasted_image_20240820155957.png)

이 신호를 다음과 같이 FFT해보자

![Pasted image 20240820160016.png](Pasted_image_20240820160016.png)

제대로 된 것 같다는 생각이 들 수 있다 그런데 기본 음원파형에 zero를 이어 붙여서 시간 간격을 늘리면 어떻게 될까

![Pasted image 20240820160101.png](Pasted_image_20240820160101.png)

![Pasted image 20240820160111.png](Pasted_image_20240820160111.png)

위의 경우는 n_fft가 window_lengths보다 클 경우, 큰 구간은 모두 zero_padding으로 채우게 된 경우이다.

이렇게 한다면 원래의 FFT보다 더 섬세하게 주파수 분석을 할 수 있다. 하지만 마냥 좋은 방법은 아닌게, 위의 방법은 주파수 해상도가 높아졌지만, 시간 해상도는 엄청나게 낮아졌다.

### window parameter

**window**는 어려운 파라미터이다. 그래도 이를 알아야 하기에 다음과 같이 서술해보겠다.

STFT 라이브러리에서 default 값은 hann으로 되어 있다. FFT를 할 때 특정 주기 간격으로 한다고 했는데, 사실 그 가정은 그 주기가 무한번 반복한다는 가정하에 계산이 이뤄지게 된다. 그렇다면 다음과 같이 파형이 생겼을 경우, 연결되는 부분에서 문제가 발생하게 된다.

![Pasted image 20240820160648.png](Pasted_image_20240820160648.png)

저 부분까지 포함해서 주파수 분석을 하기 때문에 spectral leakage가 발생한다.

![Pasted image 20240820160716.png](Pasted_image_20240820160716.png)

위 그림은 leakage가 발생한 그림이고, 이상적으로는 아래와 같이 나왔어야 한다. (단일 주파수를 가진 sin함수일 때)

![Pasted image 20240820160736.png](Pasted_image_20240820160736.png)

즉 같은 sin함수라도, 구간을 어떻게 정의하느냐에 따라 주파수 spectral에 leakage가 발생하는 것이다. 이러한 discontinuity 문제를 해결하기 위한 것이 바로 window이다. 대표적으로 hanning과 hamming이 있다.

![Pasted image 20240820160806.png](Pasted_image_20240820160806.png)

그림처럼 일종의 필터링을 하는 것이다. hanning의 경우, 그래프 구간의 양 끝을 0으로 맞춤으로써, periodic 상황에서의 discontinuity를 없애는 방식이다. 이런식으로 핕터링을 하게 되면, 주파수 분석 결과는 다음과 같다.

![Pasted image 20240820160830.png](Pasted_image_20240820160830.png)

이렇듯 데이터에 따라 다양한 윈도우를 적용할 수 있다.

### 7. Wavelet transformation

---

아까 말했든 STFT에서는 고정된 Window 사이즈에 대해서만 계산이 가능해서 주파수 해상도가 높아아지는 대신, 시간 해상도를 포기할 것이냐 아님 그 반대로 할 것이냐를 선택해야 했었다.

이번엔 그 단점을 극복한 케이스를 봐보자, Wavelet transformation은 Window 크기를 상황에 따라 바꿔가면서 활용할 수 있는 간단한 아이디어를 착안했다.

STFT가 고정된 Window를 따라간다면 이는 유동적인 Window를 따라가도록 설계한 것이다. 고주파는 Window를 더 잘게 쪼개서 시간 분해능을 높여서 보고, 반대로 저주파는 Window를 크게 적용해서 본다면 시간과 주파수 해상도를 모두 놓치지 않을 수 있다.

![Pasted image 20240821091757.png](Pasted_image_20240821091757.png)

아까 위에서 푸리에 변환은 다양한 주파수를 갖는 사인 곡선을 기본 함수로 해서, 시간 도메인에서의 신호를 주파수 도메인으로 변환한다는 것을 배웠다.

> 도메인이 뭔가요?
데이터셋과 비슷하지만 다른 개념이다, 도메인은 관찰할 그룹이고 데이터셋은 해당 관찰 그룹에서부터 파생된 데이터의 구조를 말한다. 물론 딥러닝 데이터의 관점에서는 두 그룹이 차이가 없다고 볼 수 있다. (머신 러닝과 다르게 데이터의 특징을 스스로 잡으니...), 위의 설명에서는 간단하게 독립 변수같은 개념으로 바라보면 편하다
> 

Wavelet Transform은 기존에 정의된 웨이블릿 함수를 기본 함수로 사용하여 신호를 변환하는 방법으로 공식은 다음과 같다.

> 웨이블릿은 특정한 형태의 파동(wave)을 가지며, 이 파동은 고정된 주파수의 사인 또는 코사인 함수와 달리, 시간에 따라 위치가 변하는 고유의 형태를 가지고 있다.
간단히 말해, 웨이블릿은 주어진 신호를 다양한 시간 척도에서 분석하기 위한 작은 "파형"이다.
> 

![Pasted image 20240821092218.png](Pasted_image_20240821092218.png)

이 변환은 시간 영역에서의 신호를 웨이블릿 함수를 기준으로 한다.

![Pasted image 20240821092319.png](Pasted_image_20240821092319.png)

웨이블릿은 다양한 종류로 나타나기에, 필요에 따라 유연하게 하나를 선택해서 사용할 수 있다. 웨이블릿 종류를 시간에 맞춰 Scaling(신호의 크기를 확장 또는 축소)하거나 Shifting(신호를 시간축 상의 특정 위치로 평행 이동)하여 복잡한 신호도 분석할 수 있다.

Wavelet Transform은 분석의 목적에 따라 Continuous Wavelet Transform(CWT)과 Discrete Wavelet Transform(DWT)으로 나눌 수 있다.

- CWT은 매개변수를 매우 미세하게 이산화한 후 모 웨이블릿을 적용하는 방법으로, 시간 주파수 분석 및 시간적으로 국부화된 주파수 성분의 필터링 등 연속적인 스펙트럼 분석하는 데 쓰인다.
- DWT은 웨이블릿 변환 매개변수를 이산화하여 나타나는 것을 의미하는데, 신호 및 이미지의 노이즈 제거하거나 데이터를 압축하는 데 주로 사용되고 있다.